# 8. 객체 참조, 가변성, 재활용

## 시작

실제 파이썬 프로그램에서 발생하는 여러 미묘한 버그의 핵심 원인이기도 하다.



## 8.1 변수는 상자가 아니다

'상자로서의 변수' 개념이 실제로는 객체지향 언어에서 참조 변수를 이해하는 데 방해가 된다.

파이썬 변수는 자바에서의 참조 변수와 같다.  변수는 객체에 붙은 레이블/포스트잇이라고 생각하는 것이 좋다.

레이블을 붙이는 것을 별명이라고 한다. 변수는 단지 레이블일 뿐이므로 객체에 여러 레이블을 붙이지 못할 이유가 없다.

**변수는 참조를 담고 있다.**

- 파이썬의 인수 할당

객체는 변수가 할당되기 전에 생성된다.

파이썬에서 할당문을 이해하려면 언제나 오른쪽을 먼저 읽어야 한다. 할당문의 오른쪽에서 객체를 생성하거나 가져온다. 그 후 레이블을 붙이듯이 할당문 왼쪽에 있는 변수가 객체에 바인딩된다.

'변수 s가 시소에 할당되었다'고 했지 '시소가 변수 s에 할당되었다'고 하지 않는다.

단순 할당문은 사본을 생성하지 않는다.

+=, *= 같은 복합 할당 연산자는 왼쪽 변수가 불변 객체에 바인딩되어 있을 때는 객체를 새로 생성하고, 가변 객체에 바인딩되어 있을 때는 기존 객체를 변경한다.



## 8.2 정체성, 동질성, 별명

동일한 값을 갖고 있으므로 == 연산자 (동치 연산자)에 의해 동일하다고 판단되지만, `is` 정체성을 비교하면 다르다.

모든 객체는 정체성, 자료형, 값을 가지고 있다. 코드가 실행되는 동안 객체는 값만 바뀔 뿐이다.

객체의 정체성은 일단 생성한 후에는 결코 변경되지 않는다. 정체성은 메모리 내의 객체 주소라고 생각할 수 있다.

is 연산자는 두 객체의 정체성을 비교한다. `id()` 함수는 정체성을 나타내는 정수를 반환한다.

- 객체 ID

ID는 객체마다 고유한 레이블이라는 것을 보장하며 객체가 소멸될 때까지 결코 변하지 않는다.

객체 ID의 실제 의미는 구현에 따라 다르다. CPython의 경우 id()는 객체의 메모리 주소를 반환하지만, 다른 파이썬 인터프리터는 메모리 주소 이외의 다른 값을 반환할 수도 있다.

### 8.2.1 == 연산자와 is 연산자 간의 선택

== 연산자(동치 연산자)는 객체의 값을 비교하고, is 연산자는 객체의 정체성을 비교한다.

정체성보다 값을 비교하는 경우가 많으므로, 파이썬 코드에서는 == 연산자를 is 연산자보다 자주 볼 수 있다.

변수를 싱글턴(singleton)과 비교할 때는 is 연산자를 사용해야 한다.

> 싱글턴이란?
>
> 소프트웨어 디자인 패턴에서 싱글턴 패턴을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.
>
> 인스턴스가 1개만 생성된다.

- is 연산자가 == 연산자보다 빠르다.

is 연산자는 오버로딩할 수 없다. 특별 메서드를 호출할 필요가 없다. id()값 두 정수를 비교하는 정도로 연사이 간단하기 때문이다.

- == 연산자는 `a.__eq__(b)`의 편리 구문이다.

object 객체에서 상속받은 `__eq__` 메서드는 객체의 ID를 비교하므로 is 연산자와 동일한 결과를 산출한다.

그러나 대부분의 내장 자료형은 `__eq__` 메서드를 오버라이드해서 객체의 값을 비교한다. 대형 컬렉션이나 깊이 내포된 구조체를 비교하는 경우 동치 비교는 상당한 처리를 요구한다.



### 8.2.2 튜플의 상대적 불변성

불변성으로 유명한 튜플이 생각만큼 딱딱하지 않다.

단일형 시퀀스(str, bytes, array.array)는 참조 대신 문자, 바이트, 숫자 등의 데이터를 물리적으로 연속된 메모리에 저장한다.

리스트, 딕셔너리, 집합 등 대부분의 파이썬 컬렉션과 마찬가지로 튜플도 객체에 대한 참조를 담는다. 

불변 객체는 변하지 않는다. 단, tuple이나 frozenset 등의 불변 컬렉션인 경우는 예외다.

- 불변 컬렉션이 가변 항목에 대한 참조를 담고 있는 경우, 가변 항목의 값이 바뀔 때 컬렉션의 값도 바뀐다.
- 불변 컬렉션에서 바뀌지 않는 것은 그 안에 들어 있는 객체의 정체성이며, 불변 컬렉션이 참조하는 가변 객체가 바뀌는 것을 막지 않는다. 

튜플의 불변성은 tuple 데이터 구조체의 물리적인 내용, 참조 자체만을 말하는 것이며, 참조된 객체까지 불변성을 가지는 것은 아니다.

참조된 항목이 가변형이면 튜플 자체는 불변형이지만 참조된 항목은 변할 수 있다.

그래서 일부 튜플이 해시 불가능하다. 



## 8.3 기본 복사는 얕은 복사

동질성과 정체성 간의 차이는 객체를 복사할 때 더 큰 영향을 미친다.

사본은 ID가 다른 동일한 객체다.

리스트나 대부분의 내장 가변 컬렉션을 복사하는 가장 손쉬운 방법은 그 자료형 자체의 내장 생성자를 사용하는 것이다. `list()` 내장 생성자/함수나 [:]을 사용하면 얕은 사본(shallow copy)을 생성한다.

최상위 컨테이너는 복제하지만 사본은 원래 컨테이너에 들어 있던 동일 객체에 대한 참조로 채워진다.

모든 항목이 불변형이면 이 방식은 메모리를 절약하며 아무런 문제를 일으키지 않는다. 그러나 가변 항목이 들어 있을 때는 불쾌한 문제를 야기할 수도 있다.

[예제 8-6] 
얇은 사본의 불변형 객체를 수정할 경우 새로운 객체를 만들어서 다시 참조한다. 더 이상 같은 객체가 아니다.

### 8.3.1 객체의 깊은 복사와 얕은 복사

copy 모듈이 제공하는 deepcopy는 깊은 복사를, copy 함수는 얕은 복사를 지원한다.

deepcopy 함수는 순환 참조를 제대로 처리하기 위해 이미 복사한 객체에 대한 참조를 기억하고 있다. 객체 안에 순환 참조가 있으면 단순한 알고리즘은 무한 루프에 빠질 수 있다. 

복사하면 안 되는 외부 리소스나 싱글턴을 객체가 참조하는 경우, 깊은 복사가 너무 깊이 복사할 수도 있다.
`__copy__`와 `__deepcopy__` 특별 메서드를 구현해서 copy(), deepcopy() 동작을 제어할 수 있다.



## 8.4 참조로서의 함수 매개변수

별명을 통한 객체 공유 방식은 파이썬에서 매개변수 전달이 작동하는 방식과 가변 자료형을 매개변수 기본형으로 사용하는 문제도 설명할 수 있다. 

파이썬은 공유로 호출(call by sharing)하는 매개변수 전달 방식만 지원한다.

함수 안의 매개변수는 실제 인수의 별명이 된다. 공유로 호출한다는 말은 함수의 각 매개변수가 인수로 전달받은 각 참조의 사본을 받는다는 의미다. 

이런 체계의 결과로서, 어떤 객체를 다른 객체로 바꿀 수는 없다. 함수는 인수로 전달받은 모든 가변 객체를 변경할 수 있지만, 객체의 정체성 자체는 변경할 수 없다. 

- 재바인딩(rebinding)
  - 기존 변수에 새로운 값을 할당하면 기존에 바인딩되어 있던 객체를 변경하지 않는다.
  - 변수가 새로운 객체에 바인딩되도록 만들어야 한다. 
  - 그 변수가 기존 객체를 참조하는 마지막 참조였다면, 기존 객체는 가비지 컬렉트된다.

### 8.4.1 가변형을 매개변수 기본값으로 사용하기: 좋지 않은 생각

기본값을 가진 선택적 인수는 파이썬 함수 정의에서 아주 좋은 기능으로, 하위 호환성을 유지하며 API를 개선할 수 있게 해준다. 그러나 매개변수 기본값으로 가변 객체를 사용하는 것은 피해야 한다. 

기본값이 가변 객체고, 이 객체를 변경하면 변경 내용이 향후에 이 함수의 호출에 영향을 미친다. 

가변 값을 받는 매개변수의 기본값으로 None을 주로 사용한다. 인수가 None이 아니면 인수의 사본을 할당하는 것이 올바른 방법이다.

- 함수 매개변수는 별명으로 전달된다.
  - 함수는 인수로 전달받은 가변 객체를 모두 변경할 수 있다.
  - 가변 객체의 변경을 막으려면 함수 안에서 사본을 생성하거나, 리스트 대신 튜플을 전달하는 등 불변 객체를 사용해야 한다.

### 8.4.2 가변 매개변수에 대한 방어적 프로그래밍

가변 매개변수를 받는 함수를 구현할 때는, 전달된 인수가 변경될 것이라는 것을 호출자가 예상할 수 있는지 없는지 신중하게 고려해야 한다. 함수 구현자와 함수 호출자가 예상하는 것을 일치시키는 것이다.

- 함수 매개변수의 기본값으로 가변 객체를 사용하는 것은 위험하다.
  - 매개변수를 변경하면 기본값이 변경되어 이 기본값을 사용하는 함수가 나중에 호출될 때 영향을 받기 때문이다.



## 8.5 del과 가비지 컬렉션

객체는 결코 명시적으로 제거되지 않는다. 그러나 도달할 수 없을 때 객체는 가비지 컬렉트될 수 있다.

del 명령은 별명을 제거하는 것이지, 객체를 제거하느 ㄴ것이 아니다. 

del 명령의 결과로 객체가 가비지 컬렉트될 수 있지만, 제거된 변수가 객체를 참조하는 최후의 변수거나 객체에 도달할 수 없을 때만 가비지 컬렉트된다. 

변수를 다시 바인딩해도 객체에 대한 참조 카운트를 0으로 만들어 객체가 제거될 수 있다.

`__del__` 특별 메서드는 객체가 제거되도록 만들지 않으며 사용자 코드에서 직접 호출하면 안된다. `__del__`은 객체가 제거되기 직전에 외부 리소스를 해제할 기회를 주기 위해 파이썬 인터프리터가 호출한다.

CPython의 경우 가비지 컬렉션은 주로 참조 카운트에 기반한다. 본질적으로 각 객체는 얼마나 많은 참조가 자신을 가리키는지 개수를 세고 있다. refcount가 0이 되자마자 CPython이 객체의 `__del__` 메서드를 호출하고(정의되어 있는 경우) 객체에 할당되어 있는 메모리를 해제함으로써 객체가 제거된다. 

CPython 2.0에는 순환 참조(그룹 안에서 서로 참조하고 있어서 참조 카운트는 0이 아니지만 도달할 수 없는 상태)에 관련된 객체 그룹을 탐지하기 위해 세대별 가비지 컬렉션 알고리즘(generational garbage collection algorithm)을 추가했다. 다른 파이썬 구현에서는 참조 카운트에 기반하지 않는 더 정교한 가비지 컬렉터를 사용하므로, 객체에 대한 참조가 모두 사라진 경우에도 `__del__` 메서드가 바로 호출되지 않을 수도 있다.



## 8.6 약한 참조

- CPython에서 객체는 참조수가 0이 되는 순간 제거된다.
  - 순환 참조 그룹을 형성해서 외부에서 참조할 수 없을 때도 제거된다.

- 약한 참조
  - weakref 모듈의 WeakValueDictionary, WeakKeyDictionary, WeakSet 컬렉션 및 finalize() 함수의 기반이 되는 메커니즘
  - 때로는 객체의 참조수를 증가시키지 않으면서 객체를 참조해야 하는 경우에 사용한다.
  - 자신의 객체를 모두 추적하려는 클래스의 경우가 이에 해당한다.

객체가 메모리에 유지되거나 유지되지 않도록 만드는 것은 참조의 존재 여부다. 객체 참조 카운트가 0이 되면 가비지 컬렉터는 해당 객체를 제거한다.

캐시처럼 불필요하게 객체를 유지시키지 않으면서 객체를 참조할 수 있으면 도움이 되는 경우가 있다. 

약한 참조는 참조 카운트를 증가시키지 않고 객체를 참조한다. 참조의 대상인 객체를 참조 대상이라고 한다. 따라서 약한 참조는 참조 대상이 가비지 컬렉트되는 것을 방지하지 않는다.

- weakref.ref

객체를 호출해서 참조 대상에 접근하는 방법

객체가 살아 있으면 약한 참조 호출은 참조된 객체를 반환하고, 그렇지 않으면 None을 반환한다.

weakref.ref는 고급 사용자를 위한 저수준 인터페이스. 일반 프로그래머는 weakref.ref 객체를 직접 만들기보다는 WeakkeyDictionary, WeakValueDictionary, WeakSet, finalize()를 사용하는 것이 좋다. 

### 8.6.1 WeakValueDictionary 촌극

WeakValueDictionary 클래스는 객체에 대한 약한 참조를 값으로 가지는 가변 매핑을 구현한다. 참조된 객체가 다른 곳에서 가비지 컬렉트되면 해당 키도 WeakValueDictionary 에서 자동으로 제거된다. 일반적으로 캐시를 구현하기 위해 사용된다.

WeakValueDictionary는 애플리케이션의 다른 부분에서 소유하고 있는 객체에 속성을 추가하지 않고 추가적인 데이터를 연결할 수 있다. 이 클래스는 속성 접근을 오버라이드하는 객체(디스크립터)에서 유용하다.

- WeakSet

요소를 약한 참조로 가리키는 집합 클래스. 어떤 요소에 대한 참조가 더 이상 존재하지 않으면 해당 요소가 제거된다.

자신의 객체를 모두 알고 있는 클래스를 만들어야 한다면, 각 객체에 대한 참조를 모두 WeakSet 형의 클래스 속성에 저장하는 것이 좋다.
클래스 자체가 객체에 대한 강한 참조를 하므로, 명시적으로 제거하지 않는 한 프로세스가 종료될 때까지 객체가 제거되지 않기 때문에
일반 집합을 사용하면 이 클래스로 생성한 모든 객체는 가비지 컬렉트되지 않을 것이다. 

### 8.6.2 약한 참조의 한계

모든 파이썬 객체가 약한 참조의 대상이 될 수 있는 것은 아니다. 

기본적인 list와 dict 객체는 참조 대상이 될 수 없지만 서브클래스를 만들어서 해결할 수 있다. 그러나 int, tuple 객체는 클래스를 상속해도 약한 참조의 대상이 될 수 없다.

CPython 구현 방식에 따른 제약사항이라 다른 파이썬 구현에서는 적용되지 않을 수도 있다. 내부 구현 최적화에 의해 발생되는 문제다.



## 8.7 파이선의 특이한 불변형 처리법

튜플은 tuple(), t[:]으로 작성해도 사본을 생성하지 않고 그 객체에 대한 참조를 반환한다.

str, bytes, frozenset에서도 동일한 동작을 볼 수 있다.

- 인터닝(interning)

문자열 리터럴을 공유하는 최적화 기법

스트링 리터럴은 공유 객체를 생성하기도 한다. `s1 = 'ABC' ; s2= 'ABC' ; s1 == s2 is True`

CPython에서는 0, -1, 42 등 인기 있는 숫자를 불필요하게 중복하지 않도록 작은 정수에도 동일한 기법을 사용한다.

- 선의의 거짓말 

메모리 사용량을 줄이고 인터프리터가 더 빨리 실행되게 한다.

불변형에만 적용되므로 아무런 문제도 생기지 않는다.

