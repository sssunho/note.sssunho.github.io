# 9. 파이썬스러운 객체

## 시작

지금까지 여러 내장 객체의 구조와 동작에 대해 설명했다. 이제 실제 파이썬 객체와 동일하게 동작하는 사용자 정의 클래스를 만들어보자.

파이썬 데이터 모델 덕분에 사용자가 정의한 자료형도 내장 자료형과 마찬가지로 자연스럽게 동작할 수 있다. 상속하지 않고도 객체에 필요한 메서드를 구현하면 기대한 대로 동작한다. 덕 타이핑 매커니즘을 통해 이 모든 것이 가능하다. 

- 특별 메서드 및 파이썬스러운 클래스를 생성하는 관례에 대해 설명한다.
- 단순함이 복잡함보다 낫다. (Simple is better than complex)
- 파이썬스러운 객체는 요구사항을 만족하는 한 가장 단순해야 하며, 언어 기능을 모두 갖출 필요는 없다.
- 파이썬스러운 객체를 만들려면, 실제 파이썬 객체가 어떻게 작동하는지 살펴보라.
- 9장에서 살펴본 특별 메서드
  - 문자열/바이트로 표현하는 메서드: `__repr__`, `__str__`, `__format__`, `__bytes__`
  - 객체를 숫자로 변환하는 여러 메서드: `__abs__`, `__bool__`, `__hash__`
  - bytes로 변환하고 해시할 수 있게 해주는 메서드: `__eq__`, `__hash__`



## 9. 1 객체 표현

repr() 메서드는 객체를 개발자가 보고자 하는 형태로 표혀한 문자열을 반환한다.

str() 메서드는 객체를 사용자가 보고자 하는 형태로 표현한 문자열로 반환한다.



## 9.2 벡터 클래스의 부활



## 9.3 대안 생성자

생성자를 통해서가 아닌.. 

> Alternative Constructor
>
> https://fabl1106.github.io/python/2019/03/21/%ED%8C%8C%EC%9D%B4%EC%8D%AC-14.-%EC%BD%94%EB%93%9C%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B3%B4%EB%8A%94-class.html
>
> - 객체가 하나도 없는 상태에서도 호출이 가능하다.
> - 전역 함수를 대체할 수 있다.
> - 원래 파이썬은 하나의 생성자만을 허용하지만 클래스메서드를 통해 해결 가능하다.
>   - 대체 생성자(alternative constructor)가 될 수 있다.
>   - 파이썬에서는 생성자를 하나만 가능하기때문에 여러가지 형태의 입력에 대응 할수 없다.

## 9.4 @classmethod와 @staticmethod

- `@classmethod` 데커레이터는 유용하다. `@staticmethod` 데커레이터는 그리 유용하지 않으며 모듈 수준의 함수를 사용하는 것이 더 간단하다.

@classmethod

- 클래스 자체를 첫 번째 인수로 받게 된다. 클래스 자신이 cls 매개변수로 전달된다.
- 객체가 아닌 클래스에 연산을 수행하는 메서드를 정의한다.
- 객체를 생성하기 위해 cls 인수를 이용해서 실제로 클래스의 생성자를 호출한다. 

@staticmethod

- 메서드가 특별한 첫 번째 인수를 받지 않도록 메서드를 변경한다.
- 본질적으로 정적 메서드는 모듈 대신 클래스 본체 안에 정의된 평범한 함수일 뿐이다.



## 9.5 포맷된 출력

- 포맷 명시 간이 언어(Format Specification Mini-Language)는 `__format__` 메서드를 구현해서 쉽게 확장할 수 있었다.

`format()` 내장 함수와 `str.format()` 메서드는 실제 포맷 작업을 `__format__(format_spec)` 메서드에 위임한다. 

format_spec은 포맷 명시자(format specifier)로서, 다음 두 가지 방법 중 하나를 통해 지정한다.

- format(my_obj, format_spec) 두 번째 인수
- str.format()에 사용된 포맷 문자열 안에 {}로 구분한 대체 필드 안에서 콜론 뒤의 문자열



## 9.6 해시 가능한 Vector2d

해시 가능하게 만들면 집합을 만들거나 딕셔너리의 키로 사용할 수 있다. 그 전에 불변형으로 만들어야 한다. 

- 해시 가능하게 만들기 위해 준비하면서
  - 속성을 비공개로 구현하고 읽기 전용 프로퍼티로 공개함으로써 실수로 값을 변경하지 못하도록 불변형으로 만들었다.
  - 객체 속성들의 해시를 XOR하는 권장 기법을 이용해서 `__hash__` 메서드를 구현했다.

> XOR(배타적 논리합)
>
> 배타적 논리합은 수리 논리학에서 주어진 2개의 명제 가운데 1개만 참일 경우를 판단하는 논리 연산이다

`__hash__` 메서드를 구현해야 한다. `__eq__` 메서드도 필요하다.

해시 가능하게 하려면 객체를 불변형으로 만들어야 한다.

 -> x, y 요소를 읽기 전용 속성으로 만든다.

1. 두 개의 언더바로 시작해서 속성을 비공개로 만든다.
2. @property 데커레이터: 공개 속성명을 따라 이름을 지정한다.

-> 속성을 못바꾸게끔 property 데커레이터를 붙여서 불변형으로 만든건가?



애플리케이션에서 사용할 필요가 없는 메서드를 구현하는 것은 좋은 생각은 아니다.



## 9.7 파이썬에서의 비공개 속성과 보호된 속성

파이썬에서 private 수정자가 있는 자바와 달리 비공개 변수를 생성할 수 있는 방법은 없지만, 서브클래스에서 '비공개' 성격의 속성을 실수로 변경하지 못하게 하는 간단한 메커니즘은 있다.

- 이름 장식(name mangling)

속성명을`__mood`처럼 두 개의 언더바로 시작하고 언더바 없이 또는 하나의 언더바로 끝나도록 정의하면, 파이썬은 언더바와 클래스명을 변수명 앞에 붙여 객체의 `__dict__`에 저장한다.

안전을 제공하지만, 보안기능은 아니다. 실수로 접근하는 것을 막도록 설계되어 있지만 고의적인 악용을 막지는 못한다.

모든 파이썬 개발자가 이름 장식 기능과 란쪽으로 기울어진 이름을 좋아하는 것은 아니다. 

클래스 외부에서 그런 속성에 접근하지 않는 것은 파이썬 프로그래머 사이에 일종의 금기처럼 자리 잡혀 있다.



## 9.8 `__slots__`클래스 속성으로 공간 절약하기

`__slot__` 메서드는 사용하기 까다로우므로 수백만 개 정도의 아주 많은 객체를 다룰 때만 사용할 가치가 있다.

- `__slots__`는 객체의 내부 저장소에 영향을 미치는 특별 속성이다.(메서드가 아니다)

클래스의 외부 인터페이스에는 거의 영향을 미치지 않지만, 메모리 사용량에는 엄청난 영향을 미친다.

`__slots__` 속성은 파이썬 인터프리터가 객체 속성을 딕셔너리 대신 튜플에 저장하게 만든다.

딕셔너리는 빠른 접근 속도를 제공하기 위해 내부에 해시 테이블을 유지하므로 메모리 사용량 부담이 상당히 크다. 만약 속성에 몇개 없는 수백만 개의 객체를 다룬다면 `__slots__` 클래스 속성을 이용해서 메모리 사용량을 엄청나게 줄일 수 있다.

슈퍼클래스에서 상속받은 `__slots__`속성은 서브 클래스에 영향을 미치지 않는다. 파이썬은 각 클래스에 개별적으로 정의된 `__slots__` 속성만 고려한다.

`__slots__`를 정의하려면, 이 이름의 클래스 속성을 생성하고 여기에 객체 속성 식별자들을 담은 문자열의 반복형을 할당한다.

`__slots__`를 클래스에 정의함으로써 '이 속성들이 이 클래스 객체가 가지는 속성'임을 인터프리터에 알려준다. 

수백만 개의 숫자 데이터를 처리하는 경우에는 NumPy를 사용하는 것이 좋다.

클래스 안에 `__slots__`를 명시하는 경우, 객체는 `__slots__`에 명시되지 않은 속성을 가질 수 없게 된다. 

`__slots__`는 최적화를 위해 사용하는 것이지, 프로그래머를 억압하기 위한 것은 아니다.

부주의한 최적화는 성급한 최적화보다 훨씬 더 나쁘다.

`__slots__`는 클래스의 사용자가 할당할 수 있는 속성을 제한하기 위해 사용해서느 ㄴ안된다. 

`__slots__`는 고정된 스키마의 아주 큰 데이터베이스와 같은 테이블 형태의 데이터를 사용할 때 유용하다. 



## 9.9 클래스 속성 오버라이드

클래스 속성을 객체 속성의 기본값으로 사용하는 것은 파이썬의 독특한 특징이다.

객체 속성을 이용해서 클래스 속성을 오버라이드하는 방법에 대해 설명한다.

- 객체 속성을 생성해서 오버라이드하는 방법이 있고,
  클래스를 상속해서 서브클래스의 클래스 수준에서 덮어쓰는 방법이 있다.

존재하지 않는 객체 속성에 값을 저장하면, 새로운 객체 속성을 생성하고 동일한 이름의 클래스 속성은 변경하지 않는다. 동일한 이름의 클래스 속성을 가리키게 된다. 그러면 각 객체가 서로 다른 값을 갖도록 커스터마이즈할 수 있게 된다. 

클래스 속성을 변경하려면 클래스 정의에서 직접 바꿔야 하며, 객체를 통해 변경하면 안 된다. 