# 6. 일급 함수 디자인 패턴



## 시작

디자인 패턴이 언어에 독립적이긴 하지만, 그렇다고 해서 그것이 모든 언어에 적용될 수 있는 것은 아니다.

> *리스프*(*Lisp*, *LISP*) 혹은 리습은 프로그래밍 언어의 계열로서, 오랜 역사와 독특하게 괄호를 사용하는 문법으로 유명하다.

> 처음 보는 언어, Dylan, CLOS
>
> https://en.wikipedia.org/wiki/Dylan_(programming_language)



구현 언어가 관련된 패턴을 결정한다.

일급 함수를 지원하는 언어에서는 전략, 명령, 템플릿 메서드, 비지터 패턴을 다시 생각해보라고 피터 노빅은 권고한다.
패턴에 참여하는 일부 클래스의 객체를 간단히 함수로 교체하면, 획일적으로 반복되는 코드의 상당 부분을 줄일 수 있다는 것이다.

피터 노빅은 디자인 패턴에 대해 명령 패턴, 전략 패턴, 템플릿 메서드 패턴 및 비지터 패턴은 적어도 어떠한 유스케이스에서는 일급 함수를 이용해서 더욱 간단하게 만들거나 '보이지 않게' 만들 수 있다는 메시지를 보내고 있다.

> Peter Norvig는 미국 컴퓨터 과학자입니다. Google의 연구 책임자이며 검색 품질 책임자로 일했습니다.



**6장의 목표**: 파이썬에서 함수를 일급객체로 사용하여 전략 패턴과 명령 패턴을 더욱 간단하게 구현 하는 방법을 설명한다.

<디자인 패턴>에서 설명하는 전략이나 명령 패턴을 흉내 내기보다는, 파이썬에서 함수나 콜러블 객체를 이용해서 더욱 자연스럽게 콜백을 구현할 수 있는 방법에 대해 알아본다. 

컴포넌트가 단일 메서드 인터페이스를 구현하며 그 메서드가 execute, run, doIt 등 일반적인 이름을 갖고 있는 디자인 패턴이나 API를 종종 만날 수 있다. (진짜!) 
이런 케이스를 일급 함수나 기타 콜러블을 사용해서 파이썬에서 더욱 간결하게 구현하는 방법을 알아본다. 



함수 객체를 이용해서 전략 패턴을 리팩토링하고, 비슷한 방법으로 명령 패턴을 단순화하는 방법을 설명한다.

## 6.1 사례: 전략 패턴의 리팩토링

전략 패턴은 파이썬에서 함수를 일급 객체로 사용하면 더욱 간단해질 수 있는 디자인 패턴의 대표적인 사례이다.



전략 패턴이란?

일련의 알고리즘을 정의하고 각각을 하나의 클래스 안에 넣어서 교체하기 쉽게 마든다. 전략을 이용하면 사용하는 클라이언트에 따라 알고리즘을 독립적으로 변경할 수 있다.

고객의 속성이나 주문한 상품에 따라 할인을 계산하는 전자상거래 영역에서 쉽게 볼 수 있다.



### 6.1.1 고전적인 전략

| 이름          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 콘텍스트      | 일부 계산을 서로 다른 알고리즘을 구현하는 '교환 가능한' 컴포넌트에 위임함으로써 서비스를 제공한다.<br />여러 알고리즘 중 하나에 따라 프로모션 할인을 적용하도록 설정된다. |
| 전략          | 여러 알고리즘을 구현하는 컴포넌트에 공통된 인터페이스.<br />Promotion이라는 추상 베이스 클래스가 담당한다. |
| 구체적인 전략 | '전략'의 구상 서브클래스 중 하나                             |

**구체적인 전략은 콘텍스트 <u>클래스</u>의 클라이언트에 의해 선택된다.** 
= 플러그형 할인 전략

클래스로 구현된 것이 [예제 6-1]의 포인트!



[예제 6-1]도 제대로 동작하지만, 파이썬에서 함수를 객체로 사용하면 더 적은 코드로 동일한 기능을 구현할 수 있다.



### 6.1.2  함수지향 전략

함수를 객체로 사용해서 구현하는 방법

[예제 6-1] 구체적인 전략 객체가 일반 함수로 보인다고 생각하면 제대로 본 것이다. 
discount()라는 메서드 하나만 가졌고, 상태(객체 속성)을 가지고 있지 않다.

[예제 6-3]은 구체적인 전략 객체를 함수로 변경했고, Promotion 추상 클래스를 제거하는 리팩토링을 했다.
코드가 12줄 짧아졌고, Order 객체마다 할인 전략 객체를 만들 필요 없이 할인 전략 함수를 바로 사용할 수 있게 되어 Order 객체를 사용하는 방법도 더 간단해졌다. 



전략 객체는 종종 훌륭한 플라이웨이트(flyweight)가 되기도 한다. 구체적인 전략 객체가 내부 상태를 가지고 있어서 더욱 복잡한 경우에는 모든 전략 패턴과 플라이웨이트 패턴을 혼합해서 사용해야 한다.

- Flyweight 

여러 콘텍스트에서 동시에 사용할 수 있는 객체

새로운 콘텍스트에서 동일 전략 객체를 반복해서 적용할 때는 새로 생성하는 비용을 줄이기 위해 플라이웨이트를 공유하는 것이 좋다.

전략 패턴의 단점인 '런타임 비용'을 극복하기 위해 플라이웨이트 패턴을 사용하도록 권고한다. 

소스 코드의 행 수와 유지보수 비용은 눈덩이처럼 불어난다. ❓ 왜죠?

> https://brownbears.tistory.com/509
>
> 비용이 큰 자원을 공통으로 사용할 수 있도록 만드는 패턴
>
> 중복 생성될 가능성이 높아 동일한 자원이 자주 사용될 가능성이 높을 때나 자원 생성 비용은 큰데 사용 빈도는 낮아 요청이 있을 때 생성해 제공해 주려할 때 사용되는 패턴



**하지만 내부 상태를 가지지 않고 콘텍스트에서 오는 데이터를 처리하는 경우, 일반 함수를 만드는 것이 훨씬 좋다.** (6.1.2의 핵심!)

함수는 사용자 정의 클래스보다 훨씬 가볍고 파이썬이 모듈을 컴파일할 때 단 한번만 생성되므로 플라이웨이트가 필요하지 않다. 

일반 함수도 '여러 콘텍스트에서 동시에 공유할 수 있는 공유 객체'임을 명심하자.



전략 패턴을 함수로 구현해서 발생하는 문제가 생길 수 있다. 예를 들어 주어진 Order 객체에 대해 적용할 수 있는 가장 좋은 할인 전략을 선택하는 '메타 전략'을 만든다고 가정해보자.

함수와 모듈을 객체로 활용하는 다양한 방법을 이용해서 최선의 전략을 찾아내는 방법을 알아본다.

> 메타
>
> https://developer.mozilla.org/ko/docs/Glossary/Metadata
>
> 다른 개념으로부터의 추상화를 가리키며 후자를 완성하거나 추가하는 데에 쓰인다. 
>
> 메타데이터는 데이터에 대한 데이터이다. 어떤 목적을 가지고 만들어진 데이터 (Constructed data with a purpose)



### 6.1.3 최선의 전략 선택하기: 단순한 접근법

함수가 일급 객체라는 개념에 익숙해지면 '함수를 담고 있는 데이터 구조체를 만든다'는 생각이 자연스럽게 떠오른다.

[예제 6-6] 함수 리스트를 반복해서 최대 할인액을 찾아내는 best_promo() 함수는 가독성이 좋고 제대로 작동하지만, 일부 코드가 중복되어 있어 버그가 생길 여지가 있다. ❓ 어디가 중복된거지?

여지1. 새로운 할인 전략을 추가하려면 함수를 코딩하고 이 함수를 promos 리스트에 추가해야 한다.
여지2. 새로운 할인 함수를 Order 객체에 인수로 전달해서 작동시킬 수 있지만, 이때 best_promo()는 새로운 할인 함수를 고려하지 않는다.



### 6.1.4 모듈에서 전략 찾기

6.1.4는 여지 2개를 해결하는, <u>적용할 수 있는 모든 할인 함수를 모으는</u> 두 가지 방법을 설명한다.



일단, 파이썬 모듈도 일급 객체임을 알아야 한다.

그리고 파이썬은 모듈을 다루는 여러 함수를 표준 라이브러리에서 제공된다. 



모듈화를 한 뒤 적용할 수 있는 모든 할인 함수를 모으는 방법 두가지를 알려준다. 

두 가지 방법의 전제조건: 별도의 모듈을 만들고 best_promo()를 제외한 모든 프로모션 할인 함수를 그 모듈에 넣어둔다.

주의: 무한 재귀 호출을 피하기 위해 best_promo() 자신은 걸러내야 한다.



#### 첫번째

모듈을 다루는 표준 라이브러리 중 하나인 globals() 내장 함수를 사용하여 적용할 수 있는 모든 할인 함수를 모은다. 



#### 두번째

inspect를 활용해 모듈 내부 조사를 사용하는 방법이다. 

inspect.getmemgers() 함수는 조건식(predicate) (불리언형 함수가 사용된다)으로 걸러낸 객체의 속성들을 반환한다. [예제 6-8]에서는 모듈 안에서 함수만 걸러내기 위해 inspect.isfunction() 조건식을 사용한다.

[예제 6-8]은 promotions 모듈에 할인액을 계산하는 함수들만 넣으면 함수명에 상관없이 작동한다. 누군가 promotions 모듈 안에 다른 시그너처를 가진 함수를 추가하면 best_promo() 함수가오류를 발생시킬 것이다.





## 6.2 명령

명령 패턴을 일급 함수로 대체하는 방법에 대해 설명한다.

함수를 인수로 전달하는 기법을 사용하면 명령 디자인 패턴도 구현을 단순하게 만들 수 있다.



명령 패턴의 목적은 연산을 실행하는 객체(호출자 Invoker)와 연산을 구현하는 객체(수신자 Receiver)를 분리하는 것이다. 
그래픽 애플리케이션의 메뉴 항목이 호출자며, 편집되고 있는 문서나 애플리케이션 자신이 수신자다.

명령 객체 Command를 수신자와 호출자 사이에 놓고, 명령은 execute()라는 단 하나의 메서드로 인터페이스를 구현한다. execute()는 원하는 연산을 수행하기 위해 수신자가 가지고 있는 메서드를 호출한다.
호출자는 구체적인 명령으로 설정되며, 연산을 실행하기 위해 execute() 메서드를 호출한다.

이런 방식을 사용하면, 호출자는 수신자의 인터페이스를 알 필요가 없으며, 명령의 서브클래스를 통해 서로 다른 수신자를 추가할 수 있다.



디자인 패턴에서는 '명령은 콜백에 대한 객체지향식 대체물'이라고 설명하고 있다. 그렇지만 콜백을 객체지향식 대체물로 바꿀 필요가 있을까? 항상 그런 것은 아니다.

호출자에 Command 객체 대신 간단히 함수를 바로 지정할 수 있다.

command.execute()를 호출하는 대신, 호출자는 단지 command()를 호출하면 된다.
**MacroCommand를 `__call__()` 메서드를 가진 클래스로 구현하여 콜러블 객체로 만든다.** 

고급 기능의 명령 패턴을 구현하려면 단순한 콜백 함수로는 어려울 수도 있지만, 두 가지 대안이 있다.

1. [예제 6-9]의 MacroCommand와 같은 콜러블 객체는 필요한 상태를 보관함으로써 `__call__()` 메서드 이외 메서드도 제공할 수 있다.
2. 함수가 호출된 후의 상태를 내부에 보관하기 위해 클로저를 사용할 수 있다.



단일 메서드 인터페이스를 구현하는 클래스의 객체를 콜러블로 대체했다. 모든 파이썬 콜러블이 `__call__()`이라는 단일 메서드 인터페이스를 구현하므로 이러 대안이 가능하다.





---

6장 읽을 거리는 디자인 패턴에 대한 얘기가 많아서 굉장히 흥미롭다! 꼭 읽어봐야겠다.

- [동적 언어에서의 디자인 패턴](http://norvig.com/design-patterns/) - 피터 노빅
  - 10번째 슬라이드
    파이썬은 일급 함수와 일급 자료형을 가지고 있다. 이 기능은 23개 패턴 중 10개의 패턴에 영향을 미친다.
- [GoF의 디자인 패턴](https://book.naver.com/bookdb/book_detail.nhn?bid=8942623)
- Python Cookbook, 3E. 8.21절
- Learning Python Design Patterns 
- Expert Python Programming

