# 7. 함수 데커레이터와 클로저

## 시작

함수 데커레이터는 소스 코드에 있는 함수를 '표시'해서 함수의 작동을 개선할 수 있게 해준다.

데커레이터를 자유자재로 사용하려면 먼저 클로저를 알아야 한다.



nonlocal은 파이썬 3.0에 추가된 예약 키워드 중 하나다.

클래스 중심의 엄격한 객체지향 방식을 고수한다면 이 기능을 사용하지 않고도 파이썬 프로그래머로서의 삶에 아무런 지장을 받지 않을 수 있다. 그러나 자기만의 데커레이터를 구현하고자 한다면 클로저를 속속들이 이해해야 하며, 그로거 나면 nonlocal이 필요해진다.

클로저는 콜백을 이용한 효율적은 비동기 프로그래밍과 필요에 따라 함수형 스타일로 코딩하는 데에도 필수적이다.



**7장의 목표**: 단순한 등록 데코레이터에서부터 복잡한 매개변수화된 데커레이터에 이르기까지 함수 데커레이터가 정확히 어떻게 작동하는지 설명하는 것이다.



아주 기초적인 내용부터 살펴보고, 위에서 나열한 주제들을 살펴보자

## 7.1 데커레이터 기본 지식

데커레이터의 특징

1. 데커레이터는 데커레이트된 함수를 다른 함수로 대체하는 능력이 있다.
2. 데커레이터는 **모듈이 로딩될 때 바로 실행된다.**



데커레이터는 다른 함수를 인수로 받는 콜러블(데커레이트된 함수)이다. 데커레이터는 다른 함수를 인수로 전달해서 호출하는 일반적인 콜러블과 동일하다.

데커레이터는 데커레이트된 함수에 어떤 처리를 수행하고, 함수를 반환하거나 함수를 다른 함수나 콜러블 객체로 대체한다.



```python
target = decorate(target)
```

target은 꼭 원래의 target() 함수를 가리키는 것이 아니며, decorate(target)이 반환한 함수를 가리키게 된다.



엄밀히 말해 데커레이터는 편리 구문(syntactic sugar)일 뿐이다.
런타임에 프로그래 행위를 변경하는 메타프로그래밍을 할 때 데커레이터가 상당히 편리하다.

> **메타프로그래밍**(Metaprogramming)이란 자기 자신 혹은 다른 컴퓨터 프로그램을 데이터로 취급하며 프로그램을 작성·수정하는 것을 말한다. 넓은 의미에서, 런타임에 수행해야 할 작업의 일부를 컴파일 타임 동안 수행하는 프로그램을 말하기도 한다.
>
> https://ichi.pro/ko/meta-keullaeseuleul-sayonghan-pythonic-meta-peulogeulaeming-28247448229728
>
> 파이썬에서 메타 클래스 나 데코레이터로 작업 한 적이 있다면 실제로는 파이썬에서 메타 프로그래밍을하고있는 것입니다.
>
>  Python의 데코레이터 작업은 클래스를 수정하지 않고 클래스에 새로운 기능을 추가 할 수있는 디자인 패턴을 만드는 것입니다. 데코레이터를 사용하면 필요에 따라 추가 기능을 추가하면서 클래스를 정적으로 유지하는 것이 매우 쉬워집니다



## 7.2 파이썬이 데커레이터를 실행하는 시점

데커레이터의 핵심 특징은 데커레이트된 함수가 정의된 직후에 실행된다는 것이다. 이는 일반적으로 **파이썬이 모듈을 로딩하는 시점, 즉 <u>임포트 타임</u>에 실행된다.**

함수 데커레이터는 모듈이 임포트되자마자 실행되지만, 데커레이트된 함수는 명시적으로 호출될 때만 실행된다.

임포트 타임과 런타임이라고 부르는 것의 차이를 명확히 보여준다.



데커레이터의 일반적인 특징

- 실제 코드에서는 데커레이터를 정의하는 모듈과 데커레이터를 적용하는 모듈을 분리해서 구현한다.
- 대부분의 데커레이터는 내부 함수를 정의해서 반환한다.



여기까지 '등록 데커레이터'들에 대해 알아봤다. 등록 데커레이터들은 데커레이트된 함수를 변경할 수도 있고 아닐 수도 있다.



## 7.3 데커레이터로 개선한 전략 패턴

6장에서 구현한 예제 코드를 데코레이터로 리팩토링하여 데코레이터를 썼을 때의 장점을 알아보자.



[예제 7-3] promotion 데커레이터로 채운 promos 리스트

@promotion으로 데커레이트한 함수는 모두 promos 리스트에 추가된다. best_promos()는 promos 리스트에 의존하므로 변경할 필요 없다.



6장에서 구현한 예제 코드보다 나은 점 = 데코레이터를 썼을 때의 장점

- 함수명이 특별한 형태로 되어 있을 필요 없다. (함수명이 _promo로 끝나지 않아도 된다)
- @promotion 데커레이터는 붙임으로써 데커레이트된 함수의 목적을 명확히 알려주며, 임시로 어떤 프로모션을 배제할 수 있다. 단지 데커레이터만 주석처리하면 된다.
- 프로모션 할인 전략을 구현한 함수는 @promotion 데커레이터가 적용되는 한 어느 모듈에서든 정의할 수 있다.



대부분의 데커레이터는 데커레이트된 함수를 변경한다. 즉, 내부 함수를 정의하고 그것을 반환하여 데커레이트된 함수를 대체한다. 

내부 함수를 사용하는 코드는 제대로 작동하기 위해 거의 항상 클로저에 의존한다. 클로저를 이해하기 위해 먼저 파이썬에서 변수 범위의 작동 방식에 대해 자세히 살펴보자.

## 7.4 변수 범위 규칙

```python
# [예제 7-5] 함수 본체 안에서 값을 할당하기 때문에 지역 변수가 되는 b
b = 6
def f2(a):
    print(a)
    print(b)
    b = 9
    
f2(3)
3
Traceback ...
UnboundLocalError: local variable 'b' referenced before assignment
```

파이썬이 함수 본체를 컴파일할 때 b가 함수 안에서 할당되므로 b를 지역 변수로 판단한다.

생성된 바이트코드를 보면 이 판단에 의해 지역 환경에서 변수 b를 가져오려 한다는 것을 알 수 있다. 지역 변수 b의 값을 가져오려 할 때 b가 바인딩되어 있지 않다는 것을 발견한다.

이 현상은 버그가 아니고 설계 결정사항이다. 파이썬은 변수가 선언되어 있기를 요구하지 않지만, 함수 본체 안에서 할당된 변수는 지역 변수로 판단한다.

global키워드를 이용해서 선언하면, 함수 안에 할당하는 문장이 있지만 인터프리터가 b를 전역 변수로 다룬다.

```python
b = 6
def f2(a):
    global b
    print(a)
    print(b)
    b = 9
```



dis 모듈을 사용하여 파이썬 함수를 바이트코드로 디스어셈블할 수 있다. (바이트코드로 볼 수 있다.)

[예제 7-7] f2() 함수를 보면, LOAD_FAST b를 지역 변수로 간주하고 있음을 알 수 있다.



파이선에서 변수 범위 작동 방식에 대해 자세히 살펴보았으니, 이제 클로저에 대해 알아보자.

## 7.5 클로저

익명 함수 != 클로저

익명 함수를 이용하면서 함수 안에 함수를 정의하는 방식이 보편화되었기 때문에, 그리고 클로저는 내포된 함수 안에서만 의미가 있어서 익명함수=클로저라고 생각하는 듯. 

**클로저는 함수 본체에서 정의하지 않고 참조하는 비전역(nonglobal) 변수를 포함한 확장 범위를 가진 함수다. 함수가 익명 함수인지 여부는 중요하지 않다. 함수 본체 외부에 정의된 비전역 변수에 접근할 수 있다는 것이 중요하다.** (꼭 이해하고 넘어갈 것)



```python
def make_averager():
    series = []	# 여기부터 def averager 코드까지 클로저 
    
    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total/len(series)
    
    return averager
```

```python
avg = make_averager()
avg(10)
> 10.0
avg(11)
> 10.5
avg(12)
> 11.0
```

make_averager() 함수 본체 안에서 series=[]로 초기화하고 있으므로 series는 이 함수의 지역변수다. 그렇지만 avg(10)을 호출할 때, make_averager() 함수는 이미 반환했으므로 지역 범위도 이미 사라진 후다. 

**average 안에 있는 series는 자유 변수(free variable)다. 자유 변수라는 말은 지역 범위에 바인딩되어 있지 않은 변수를 의미한다.**

[그림 7-1] averager에 대한 클로저는 자유 변수 series를 포함하기 위해 함수 범위를 확장한다. (클로저 범위와 자유변수 확인!)

```python
avg.__code__.co_freevars
```

함수 조사하기. series에 대한 바인딩을 반환된 avg() 함수의 `__closure__` 속성에 저장된다. `avg.__closure__`의 각 항목은 `avg.__code__.co_freevars`의 이름에 대응된다. 이 항목은 cell 객체며, 이 객체의 cell_contents 속성에서 실제 값을 찾을 수 있다.



**클로저는 함수를 정의할 때 존재하던 자유 변수에 대한 바인딩을 유지하는 함수다.** 따라서 함수를 정의하는 범위가 사라진 후에 함수를 호출해도 자유 변수에 접근할 수 있다.

**함수가 '비전역' 외부 변수를 다루는 경우는 그 함수가 다른 함수 안에 정의된 경우뿐이라는 점에 주의하라.**



## 7.6 nonlocal 선언

[예제 7-13] 전체 이력을 유지하지 않고 이동 평균을 계산하는 잘못된 고위 함수

count가 수치형이거나 어떤 가변형일 때 count += 1 문이 실제로는 count = count + 1을 의미하기 때문에 문제가 발생한다.

숫자, 문자열, 튜플 등 불변형은 읽을 수만 있고 값은 갱신할 수 없다. averager() 본체 안에서 count 변수에 할당하면 변수를 다시 바인딩하기 때문에 암묵적으로 count라는 지역 변수를 만든다. count가 더 이상 자유 변수가 아니므로 클로저에 저장되지 않는다. 

이 문제를 해결하기 위해 파이썬 3에 nonlocal이 소개되었다. 변수를 nonlocal로 선언하면 함수 안에서 변수에 새로운 값을 할당하더라도 그 변수는 자유 변수임을 나타낸다.
새로운 값을 nonlocal 변수에 할당하면 클로저에 저장된 바인딩이 변경된다. 

```python
# [예제 7-14] 전체 이력을 유지하지 않고 이동 평균 계산하기(nonlocal로 수정)
def make_averager():
    count = 0
    total = 0
    
    def averager(new_value):
        nonlocal count, total
        count += 1 
        total += new_value
        return total / count
    return averager
```



클로저와 nonlocal을 완전히 이해하면 데커레이터를 만들 수 있을 뿐만 아니라, GUI 방식의 이벤트 주도 프로그램이나 콜백을 이용한 비동기 입출력을 구현할 때도 큰 도움이 된다.



## 7.7 간단한 데커레이터 구현하기

[예제 7-15] func가 자유 변수이며, clocked()에 대한 클로저에 자유 변수 func가 들어가야 이 코드가 작동한다.

전형적인 데커레이터의 작동 방식: 데커레이트된 함수를 동일한 인수를 받는 함수로 교체하고, (일반적으로) 데커레이트된 함수가 반환해야 하는 값을 반환하면서, 추가적인 처리를 수행한다.



'추가적인 책임을 객체에 동적으로 부여한다'는 설명은 함수 데커레이터의 경우에는 적합하다. 그렇지만 구현 수준에서 파이썬 데커레이터는 고전적인 데커레이터의 작동 방식과 닮은 점이 거의 없다.



[예제 7-15] 몇개의 단점을 가지고 있다. 

- 키워드 인수를 지원하지 않는다
- 데커레이트된 함수의 `__name__`, `__doc__` 속성을 가린다.

제대로 작동하는 데커레이터를 만들기 위한 헬퍼 functools.wraps() 데커레이터를 이용해서 func에서 clocked로 관련된 속성을 복사하고 키워드 인수도 제대로 처리하게 할 수 있다.



## 7.8 표준 라이브러리에서 제공하는 데커레이터

파이썬에서 <u>메서드</u>를 데커레이트하기 위해 property(), classmethod(), staticmethod() 총 3개의 내장 함수를 제공한다. (뒤에서 나온다)

자주 사용하는 데커레이터는 functools.wraps()이며, 가장 인상적인 데커레이터는  lru_cache()와 singledispatch()다.

### 7.8.1 functools.lru_cache()를 이용한 메모이제이션

functools.lru_cache()는 메모이제이션(memoization)을 구현한다. 메모이제이션은 이전에 실행한 값비싼 함수의 결과를 저장함으로써 이전에 사용된 인수에 대해 다시 계산할 필요가 없게 해준다. 이름 앞에 붙은 LRU는 Least Recently Used(사용한지 가장 오래된)의 약자로서, 오랫동안 사용하지 않은 항목을 버림으로써 캐시가 무한정 커지지 않음을 의미한다.

lru_cache() 데커레이터는 설정 매개변수를 받기 때문에 일반 함수처럼 호출해야 한다.

lru_cache()는 maxsize, typed 두 개의 선택적 인수를 설정할 수 있다.

- maxsize: 얼마나 많은 호출을 저장할지 결정한다. 캐시가 가득차면 가장 오래된 결과를 버리고 공간을 확보한다. 최적의 성능을 내기 위해 maxsize는 2의 제곱이 되어야 한다.
- typed: True로 설정되는 경우 인수의 자료형이 다르면 결과를 따로 저장한다. 예를 들어 실수형 인수와 정수형 인수를 구분해야 하는 경우.

lru_cache()는 결과를 저장하기 위해 딕셔너리를 사용하고, 호출할 때 사용한 위치 인수와 키워드 인수를 키로 사용하므로, 데커레이트된 함수가 받는 인수는 모두 해시 가능해야 한다.

> 해시 가능하다
>
> 수명 주기 동안 결코 변하지 않는 해시값을 갖고 있고(`__hash__()` 메서드가 필요하다), 다른 객체와 비교할 수 있으면(`__eq__()` 메서드가 필요하다), 객체를 해시 가능하다고 한다. 동일하다고 판단되는 객체는 반드시 해시값이 동일해야 한다.

### 7.8.2 단일 디스패치를 이용한 범용 함수

[예제 7-20] 다른 객체형에 맞춰진 HTML을 생성하는 htmlize(). 코드 확장

파이썬에서는 메서드나 함수의 오버로딩을 지원하지 않으므로, 서로 다르게 처리하고자 하는 자료형별로 서로 다른 시그너처를 가진 htmlize()를 만들 수 없다. 

이때 파이썬에서는 일반적으로 htmlize()를 디스패치 함수로 변경하고, 일련의 if/elif/else 문을 이용해서 htmlize_str(), htmlize_int() 등의 특화된 함수를 호출한다. 그러면 이 모듈의 사용자가 코드를 확장하기 쉽지 않으며 다루기도 어렵다. 시간이 지나면서 디스패치 코드가 커지며, 디스패치 함수와 특화된 함수 간의 결합이 너무 강해진다.

파이썬 3.4에서 새로 소개된 functools.singledispatch() 데커레이터는 각 모듈이 전체 해결책에 기여할 수 있게 해주며, 여러분이 편집할 수 없는 클래스에 대해서도 특화된 함수를 쉽게 제공할 수 있게 해준다.

일반 함수를 @singledispatch로 데커레이트하면, 이 함수는 범용 함수(generic function)가 된다. 즉, 일련의 함수가 첫 번째 인수의 자료형에 따라 서로 다른 방식으로 연산을 수행하게 된다.



[예제 7-21] 여러 함수를 범용 함수로 묶는 커스텀 htmlize.register()를 생성하는 singledispatch

- @singledispatch()는 객체형을 다룰 기반 함수
- 각각의 특화된 함수는 @<기반함수>.register(<객체형>)으로 데커레이트 한다.
- 특화된 함수의 이름은 필요 없으므로 언더바로 함수명을 지정한다.
- 동일한 함수로 여러 자료형을 지원하기 위해 register 데커레이터를 여러 개 쌓아 올릴 수 있다.
- int, list 같은 구상 클래스보다 numbers.Integer, abc.MutableSequence와 같은 추상 베이스 클래스를 처리하도록 특화된 함수를 등록하는 것이 좋다. 추상 베이스 클래스로 등록하면 호환되는 자료형을 폭넓게 지원할 수 있다.



singledispatch 매커니즘 장점

- 특화된 함수를 시스템 어디에나, 어느 모듈에나 등록할 수 있다
- 새로운 사용자 정의 자료형이 추가된 모듈을 추가할 때도 추가된 자료형을 처리하도록 새로운 특화된 함수를 쉽게 추가할 수 있다.
- 직접 작성하지 않고 변경할 수 없는 클래스에 대한 특화된 함수도 추가할 수 있다.
- 모듈화된 확장을 지원한다. 각 모듈은 자신이 지원하는 자료형에 대한 특화된 함수를 등록할 수 있다. (같은 자료형 여러개에 등록하면 어떻게 되지?)

자바 스타일의 메서드 오버로딩을 파이썬에 적용하기 위해 설계된 것이 아니다. (오버로딩은 단일 코드 유닛(클래스나 함수)에 너무 많은 책임을 부여하는 결함이 있다.)



데커레이터는 함수이므로 조합할 수도 있다. 조합된 데커레이터가 어떻게 작동하는지 알아보자

## 7.9 누적된 데커레이터

하나의 함수 f()에 두 데커레이터 @d1과 @d2를 차례대로 적용하면, 결과를 f=d1(d2(f))와 동일하다.



## 7.10 매개변수화된 데커레이터

인수를 받아 데커레이터를 반환하틑 데커레이터 팩토리를 만들고 나서, 데커레이트될 함수에 데커레이터 팩토리를 적용하면 된다.

### 7.10.1 매개변수화된 등록 데커레이터

```python
# [예제 7-23] 매개변수를 받기 위해 함수로 호출되어야 하는 새로운 register() 데커레이터
registry = set()

def register(active=True):	# 선택적 키워드 인수를 받는다.
    def decorate(func):	# 실제 데커레이터. 함수를 인수로 받는다.
        print('running register(active=%s)->decorate(%s)' % (active, func))
        if active:
            registry.add(func)
        else:
            registry.discard(func)
        return func	# decorate()는 데커레이터이므로 함수를 반환한다.
    return decorate	# register()는 데커레이터 팩토리이므로 decorate()를 반환한다.


# 인수를 전달하지 않더라도 register는 여전히 함수로 호출해야 하므로 @register() 형태로 호출한다. 그러면 실제 데커레이터인 decorate()를 반환한다.
@register()
def f2():
    print('running f2()')
                
```

*커머셜 앳(@)* 구문을 사용하는 대신 register()를 일반 함수로 사용하려면 괄호를 사용한 구문이 필요하다. `register(active=False)(f)`로 호출해야 한다.

매개변수화된 데커레이터는 일반적으로 데커레이트된 함수를 대체하며, 생성하기 위해 함수를 한 단계 더 내포한다.

### 7.10.2 매개변수화된 clock 데커레이터

```python
# [예제 7-25] 매개변수화된 clock() 데커레이터
import time

DEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -> {result}'

def clock(fmt=DEFAULT_FMT):  # <1> 매개변수화된 데커레이터 팩토리
    def decorate(func):      # <2> 실제 데커레이터
        def clocked(*_args): # <3> 데커레이트된 함수를 래핑
            t0 = time.time()
            _result = func(*_args)  # <4> 데커레이트된 함수의 실제 결과를 _result에 저장
            elapsed = time.time() - t0
            name = func.__name__
            args = ', '.join(repr(arg) for arg in _args)  # <5> _args가 실제 clocked()의 인수를 담고 있음 
            result = repr(_result)  # <6>
            print(fmt.format(**locals()))  # <7> fmt가 clocked()의 지역 변수를 모두 참조할 수 있게 해준다.
            return _result  # <8> clocked()는 데커레이트된 함수를 대체하므로, 원래 함수가 반호나하는 값을 반환해야 한다.
        return clocked  # <9> decorate()는 clocked()를 반환한다.
    return decorate  # <10> clock()은 decorate()를 반환한다.

if __name__ == '__main__':

    @clock()  # <11> 인수 없이 clock()을 호출하므로, 적용된 데커레이터는 기본 포맷 문자열을 사용한다.
    def snooze(seconds):
        time.sleep(seconds)

    for i in range(3):
        snooze(.123)
```

매개변수화된 데커레이터는 거의 항상 최소 두 단계의 내포된 함수를 가지고 있으며, 더 고급 기법을 지원하는 데커레이터를 구현하기 위해 `@functools.wraps`를 사용하는 경우 세 단계 이상 내포되기도 한다.



데커레이터는 `__call__()`을 구현하는 클래스로 만들 때 가장 잘 구현된다고 생각하지만 데커레이터의 기본 개념을 설명하기에는 함수가 이해하기 더 쉽다고 한다.





---

- 파이썬이 데커레이터 구문을 평가하는 방식
  - 7.2 파이썬이 데커레이터를 실행하는 시점
  - 파이썬이 모듈을 로딩하는 시점인 <u>임포트 타임</u>에 실행된다. 데커레이트된 함수가 정의된 직후에 실행된다.
- 변수가 지역 변수인지 파이썬이 판단하는 방식
  - 7.4 변수 범위 규칙
  - 파이썬은 변수가 선언되어 있기를 요구하지 않지만, 함수 본체 안에서 할당된 변수는 지역 변수로 판단한다.
- 클로저의 존재 이유와 작동 방식
  - 클로저는 함수를 정의할 때 존재하던 자유 변수, '비전역' 외부 변수에 대한 바인딩을 유지하는 함수이다.
  - 클로저는 비전역 변수를 포함한 확장 범위를 가진 **함수**
  - 클로저는 내포된 함수 안에서만 의미가 있다. 
- nonlocal로 해결할 수 있는 문제
  - 숫자, 문자열, 튜플 등 불변형은 내부 함수 안에서 다시 할당하면 다시 바인딩하기 때문에 지역 변수로 다시 생성되어 클로저에 저장되지 않는 문제가 있다. 
  - nonlocal로 선언하고 새로운 값을 할당하면 클로저에 저장된 바인딩이 변경된다.
- 표준 라이브러리에서 제공하는 재미있는 데커레이터들을 살펴보았다.
  - functools.lru_cache()로 메모이제이션(memoization) 구현
    - 이전에 실행한 값비싼 함수의 결과를 저장함으로써 이전에 사용된 인수에 대해 다시 계산할 필요가 없게 해준다
  - functools.singledispatch() 데커레이터
    - 모듈화된 확장을 지원한다. 각 모듈은 자신이 지원하는 자료형에 대한 특화된 함수를 등록할 수 있다
    - 자바 스타일의 메서드 오버로딩을 파이썬에 적용하기 위해 설계된 것이 아니다
- 잘 작동하는 데커레이터, 매개변수화된 데커레이터를 구현해보았다.
  - 내부 함수를 가지지 않는 간단한 데커레이터로 시작해서 두 단계의 내포된 함수를 가지 매개변수화된 데커레이터까지 살펴봤다.
- 우리는 메타프로그래밍의 영역에 들어섰다.
  - 런타임에 수행해야 할 작업의 일부를 임포트 타임 동안 수행하는 것을 말하는데, 데코레이터를 활용하여 메타 프로그래밍을 했보았다.
  - 임포트 타임과 런타임의 차이를 알게 되었다.
- 등록 데커레이터는 본질적으로 간단한 메커니즘이지만 고급 파이썬 프레임워크에서 실제 사용되고 있다.
  - 전략 디자인 패턴을 개선하기 위해 등록 개념을 적용했다.

